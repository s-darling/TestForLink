package com.orchestranetworks.geomatch.match;

import java.io.IOException;
//import java.nio.file.Paths;

import com.onwbp.adaptation.Adaptation;
import com.onwbp.adaptation.AdaptationName;
//import com.onwbp.adaptation.Adaptation;
import com.onwbp.adaptation.AdaptationTable;
import com.onwbp.adaptation.ReadContext;
import com.onwbp.adaptation.XPathExpressionHelper;
//import com.onwbp.adaptation.xpath.XPaExpressionHelper;
import com.orchestranetworks.instance.HomeKey;
import com.orchestranetworks.instance.Repository;
//import com.onwbp.adaptation.AdaptationHome;
//import com.orchestranetworks.instance.Repository;
import com.orchestranetworks.instance.ValueContext;
import com.orchestranetworks.schema.Path;
import com.orchestranetworks.service.OperationException;
import com.orchestranetworks.geomatch.match.AddressConverter;
import com.orchestranetworks.workflow.DataContextReadOnly;
//import com.orchestranetworks.workflow.ScriptTask;
import com.orchestranetworks.workflow.ScriptTaskBean;
import com.orchestranetworks.workflow.ScriptTaskBeanContext;

public class CarmenSandiago extends ScriptTaskBean {

	// Adaptation record = getTable(Paths.get(/*address table goes in here?*/));

	@Override
	public void executeScript(ScriptTaskBeanContext context) throws OperationException {
		// Basically the main method
		DataContextReadOnly dc = context.getProcessInstance().getDataContext();
		Adaptation a = getRecord(dc.getVariableString("record"),
				GeomatchDataset, true, true);
		String add = a.getString(Path.parse("_address"));

		// get to the table
		// Then, get the address from the table
		// Then put Lat/Long back in the table. 

	}

	public final static Adaptation GeomatchDataset = Repository.getDefault()
			.lookupHome(HomeKey.forBranchName("Geomatch")).findAdaptationOrNull(AdaptationName.forName("Geomatch"));

	// need primary key of record wanting to look for as all values can change
	// magic to reverse lookup

	public static Adaptation lookUpRecord(ValueContext vc) {
		Adaptation returnable = null;
		try {
			returnable = GeomatchDataset.getTable(vc.getAdaptationTable().getTablePath())
					.lookupAdaptationByPrimaryKey(vc);
		} catch (Exception e) {
			System.err.println("Could not look up record in Geomatch database.");
			e.printStackTrace();
		}
		return returnable;
	}
	/**
	 * Get a record based on the xpath.
	 * 
	 * @see XPathExpressionHelper.lookupFirstRecordMatchingXPath(boolean,
	 *      Adaptation, String)
	 *
	 * @param recordXpath
	 *            the xpath
	 * @param dataSet
	 *            the data set
	 * @param checkActualPrimaryKey
	 *            Whether the xpath specifies each member of the primary key,
	 *            for faster lookup
	 * @param errorIfNotFound
	 *            Whether to consider not found to be an error
	 * @throws OperationException
	 *             if an error occurs, or if not found and
	 *             <code>errorIfNotFound</code> is <code>true</code>
	 */
	public static Adaptation getRecord(String recordXpath, Adaptation dataSet,
			boolean checkActualPrimaryKey, boolean errorIfNotFound)
			throws OperationException {
		if (recordXpath == null || dataSet == null) {
			return null;
		}
		Adaptation recordAdaptation = XPathExpressionHelper
				.lookupFirstRecordMatchingXPath(checkActualPrimaryKey, dataSet,
						recordXpath);
		if (recordAdaptation == null && errorIfNotFound) {
			throw OperationException.createError("Record for '" + recordXpath
					+ "' has not been found");
		}
		return recordAdaptation;
	}
	// Get the address from the table
	// the address is a string, so I'll be passing the string to the method
	// send the address to AddressConverter.

	public static Double convertToLat(String address) throws NumberFormatException, IOException {
		//AddressConverter add = new AddressConverter();
		Double latty = Double.parseDouble(AddressConverter.ResLat(address));
		return latty;
		// return latty 
		// sure use it to push it to the table if that already exists lol
	}

	public static void setLatToTable(ValueContext context, double lat) {
		String tablePath = "Some string leading to the table?";
		final AdaptationTable table = ((ReadContext) context).getTable(Path.parse(tablePath));
		
	}

	// this will become the method that calls AddressConverter
	public static Double convertToLng(String address) throws NumberFormatException, IOException {
		//AddressConverter add = new AddressConverter();
		Double lng = Double.parseDouble(AddressConverter.ResLng(address));
		return lng;
		// return latty or push it to the table? Push it to the table. Or use
		// the return to push it to the table
		// sure use it to push it to the table if that already exists lol
	}

	public static void setLngToTable(ValueContext context, double lng) {

	}

}
